//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {
    
	private static final Record DELETE = new Record("Deleted Record");
	
	private int m; // size of table
	private int n; // number of elements currently in table
	private Record[] recordTable;
	private int[] rHashKeyTable;
	
    //
    // Create an empty table big enough to hold maxSize records.
    //
    public StringTable(int maxSize) 
    {
    	m = 2;
    	n = 0;
    	recordTable = new Record[m];
    	rHashKeyTable = new int[m];
    	
    }
    
    
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
    public boolean insert(Record r) 
    { 
    	while (n >= m/4) {
    		extendTable();
    	}
    	
    	int rHashKey = toHashKey(r.key);
    	int currentKeyValue = baseHash(rHashKey);
    	int numSteps = 0;
    	while(recordTable[currentKeyValue] != null && !recordTable[currentKeyValue].equals(DELETE)) {
    		
    		if (rHashKeyTable[currentKeyValue] == rHashKey) {
    			if (recordTable[currentKeyValue].key.equals(r.key)) {
    				return false;
    			}
    		} 
    		if (numSteps == m - 1) {
    			return false;
    		}
    		
    		numSteps++;
    		currentKeyValue = (currentKeyValue + stepHash(rHashKey))%m;
    	}
    	
    	recordTable[currentKeyValue] = r;
    	rHashKeyTable[currentKeyValue] = rHashKey;
    	
    	n++;
    	
    	return true; 
    }
    
    private void extendTable() 
    {
    	Record[] oldRecordTable = recordTable;
    	
    	m *= 2;
    	recordTable = new Record[m];
    	rHashKeyTable = new int[m];
    	n = 0;
    	for(int i = 0; i < oldRecordTable.length; i++) {
    		if (oldRecordTable[i] != null && oldRecordTable[i] != DELETE)
    		insert(oldRecordTable[i]);
    	}
    }
    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	int rHashKey = toHashKey(r.key);
    	int currentKeyValue = baseHash(rHashKey);
    	int numSteps = 0;
    	while(recordTable[currentKeyValue] != null) {
    		
    		if (rHashKeyTable[currentKeyValue] == rHashKey) {
	    		if (recordTable[currentKeyValue].key.equals(r.key)) {
	    			
	    			recordTable[currentKeyValue] = DELETE;
	    			rHashKeyTable[currentKeyValue] = 0;
	    			return;
	    		} 
    		}
    		if (numSteps == m - 1){
    			return;
    		}
    		
    		numSteps++;
    		currentKeyValue = (currentKeyValue + stepHash(rHashKey))%m;
    	}
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int rHashKey = toHashKey(key);
    	int currentKeyValue = baseHash(rHashKey);
    	int numSteps = 0;
    	while(recordTable[currentKeyValue] != null){
    		
    		if (rHashKeyTable[currentKeyValue] == rHashKey) {
				if (recordTable[currentKeyValue].key.equals(key)) {
					return recordTable[currentKeyValue];
				} 
    		}
    		if (numSteps == m - 1){
    			return null;
    		}
    		
    		numSteps++;
    		currentKeyValue = (currentKeyValue + stepHash(rHashKey))%m;
    	}
    	
    	return null;
    }
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s)
    {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
    	double multiplier = (Math.sqrt(5)-1.)/2.;
    	int key = (int)Math.floor(m*(hashKey*multiplier - Math.floor(hashKey*multiplier)));
	return key;
    }
    
    int stepHash(int hashKey)
    {
    	double multiplier = (Math.sqrt(11)-2.)/2.;
    	int keyIncrease = (int)Math.floor(m*(hashKey*multiplier - Math.floor(hashKey*multiplier)));
	return keyIncrease;
    }
}
